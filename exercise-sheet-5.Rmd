---
title: "Arbeitsblatt 5: Nichtlineare Programmierung und CasADi"
---

---------------------------------


:::: {#explaining .message-box }

::: {#note-exp .note-header}
```{r, include=knitr::is_html_output(), echo=FALSE,}
knitr::include_graphics("figures/infoicon.svg")
```
**Note**
:::
::: {#note-exp .note-body}

Alle Aufgaben sowie die dazugehörigen Dateien können [hier](http://bioinf.uni-freiburg.de/Lehre/Courses/latest/material/optimierung-uebung4.zip) heruntergeladen werden.

:::

::::

# Einführung in CasADi

[CasADi](https://web.casadi.org) ist eine open-source Toolbox zur schnellen Implementierung von nichtlinearen Optimierungsproblemen.
Der CasADi Code selber ist in C++ geschrieben, aber es gibt Interfaces für Python,
Matlab und Octave. Ableitungen werden automatisch über Algorithmische Differenzierung (AD)
berechnet, ein effizientes und gleichzeitig präzises Verfahren. Zum Lösen der Probleme kann Ca-
sADi diese an verschiedene (alleinstehende) Solver übergeben. Der open-source Solver IPOPT, ein
nichtlineares Innere-Punkt-Verfahren, ist in einer CasADi-Installation bereits enthalten.
Nichtlineare Programme werden in CasADi in der Standardform

\begin{equation}
\begin{aligned}
& \min_{x \in \mathbb{R}^n}
& & f(x) \\
& \text{s.t.}
& & x_{\text{lb}} \leq x \leq x_{\text{ub}}, \\
& & & g_{\text{lb}} \leq g(x) \leq g_{\text{ub}}
\end{aligned}
\end{equation}
formuliert, wobei die vektorwertige Funktion \( g : \mathbb{R}^n \rightarrow \mathbb{R}^m \) zusammen mit den Begrenzungen \( g_{\text{lb}}, u_{\text{lb}} \in \mathbb{R}^m \) die nichtlinearen Nebenbedingungen ausdrückt.
Für dieses Übungsblatt werden wir die Hilfsumgebung [Opti Stack](https://web.casadi.org/docs/#document-opti) nutzen, welche eine Syntax bietet, die sehr nah an die Papiernotation angelehnt ist. Die so formulierten NLP werden automatisch in die Standardform (1) übertragen.

**Aufgaben:**

1. Installieren Sie CasADi. Wenn Sie Anaconda nutzen, aktivieren Sie zunächst das Environment, in dem Sie installieren wollen.
Installieren Sie dort zunächst pip (`conda install pip`), gefolgt von der CasADi-Installation mit `pip install casadi`.
Wenn Sie standardmäßig pip verwenden, können Sie CasADi direkt in Ihr gewünschtes Environment installieren.

2. Machen Sie sich mit den bereitgestellten Codebeispielen vertraut und führen diese aus. `puppy.py` enthält eine Implementierung der Bildrekonstruktion, die Sie bereits aus Übung 2 kennen. `chain.py` implementiert eine hängende Kette.
Beide Beispiele werden in den folgenden Abschnitten kurz vorgestellt.

---

## Beispiel 1: Bildrekonstruktion

Wir haben ein verrauschtes schwarz-weiß Bild in Form der Matrix \( Y \in \mathbb{R}^{r \times c} \) gegeben, sodass die Elemente die Intensität der einzelnen Pixel definieren, \( 0 \leq Y_{i,j} \leq 256 \).
Ziel ist es, eine weniger verrauschte Version \( X \in \mathbb{R}^{r \times c} \) zu rekonstruieren. Dies kann als das unbeschränkte Optimierungsproblem formuliert werden.

$$
\min_{X \in \mathbb{R}^{r \times c}} \sum_{i=1}^r \sum_{j=1}^c \left( \sqrt{(X_{i,j} - Y_{i,j})^2 + 1} + \alpha \left( \sqrt{(X_{i,j} - X_{i+1,j})^2 + 1} + \sqrt{(X_{i,j} - X_{i,j+1})^2 + 1} \right) \right)
$$


```{r, echo=FALSE, out.width='40%', fig.align='center', fig.show='hold', fig.cap='**Abbildung 1** - Beispiel einer durch Lösung von Problem (2) erhaltenen Rekonstruktion. Links: Verrauschtes Original Y. Rechts: Rekonstruierte Version $X$ mit $\\alpha = 0.5$.'}
knitr::include_graphics(c("figures/sheet-5/p1.png", "figures/sheet-5/p2.png"))
```

formuliert werden. Hierbei haben wir "Phantompixel" \( X_{r+1,j} \) und \( X_{i,c+1} \) angenommen, mit \( X_{r+1,j} = X_{r,j} \) und \( X_{i,c+1} = X_{i,c} \), um das Definieren der Summenindizes zu erleichtern.
Abbildung 1 zeigt ein Beispiel einer so erhaltenen Rekonstruktion mit \( \alpha = 0.5 \).

---

## Beispiel 2: Bildrekonstruktion

Wir betrachten eine Kette, bestehend aus \( N \) Massepunkten, die durch \( N-1 \) Federn verbunden sind.
Die Massepunkte haben Masse \( m \) und Positionen \( (y_i, z_i) \), mit \( {i = 0, \ldots, N} \).
Die beiden äußersten Massepunkte sind fixiert, \( (y_1, z_1) = (-2, 1) \) sowie \( (y_N, z_N) = (2, 1) \).
Wir wollen eine Ruheposition der Kette finden, was der Minimierung der Kettenenergie \( V(y, z) \) entspricht.
Diese setzt sich zusammen aus der Lageenergie der Massen sowie der potentiellen Energie der Federn:

$$
V(y, z) = \sum_{i=0}^{N} mgz_i + \frac{1}{2} \sum_{i=0}^{N-1} D \left( (y_i - y_{i+1})^2 + (z_i - z_{i+1})^2 \right),
$$

wobei \( g \) die Erdbeschleunigung ist und \( D \) die Federkonstante. Wir führen nun zwei Variationen dieses Problems ein.

1. Unterhalb der Kette befindet sich eine ebene Fläche, die die Kette nach unten beschränkt. Dies drücken wir durch die Nebenbedingung \( z_i \geq 0 \) aus.
2. Unterhalb der Kette befindet sich ein Hügel. Diesen drücken wir durch die Nebenbedingung \( z_i \geq -y_i^2 \) aus.

Alles zusammen führt uns zu folgenden nichtlinearen Programmen:

**Variation 1**
$$
\begin{aligned}
\underset{y,z \in \mathbb{R}^N}{\text{min}} \quad & V(y, z) \\
\text{s.t.} \quad & (y_1, z_1) = (-2, 1), \\
& (y_N, z_N) = (2, 1),  \\
& z_i \geq 0, \quad 1 \leq i \leq N
\end{aligned}
$$

**Variation 2**
$$
\begin{equation}
\begin{aligned}
\underset{y,z \in \mathbb{R}^N}{\text{min}} \quad & V(y, z)\\
\text{s.t.} \quad & (y_1, z_1) = (-2, 1), \\
& (y_N, z_N) = (2, 1), \\
& z_i \geq -y_i^2, \quad 1 \leq i \leq N
\end{aligned}
\end{equation}
$$

Beachten Sie, dass es sich bei NLP (4) um ein konvexes QP handelt (wieso?), während (5) ein nichtkonvexes NLP ist. In `chain.py` finden Sie eine vollständige Implementierung beider Probleme hier von. Abbildung 2 zeigt die Lösungen der beiden Variationen. Für Variation 2 sind zwei mögliche Lösungen dargestellt.

```{r, echo=FALSE, out.width='80%', fig.align='center', fig.show='hold', fig.cap='**Abbildung 2** - Illustration der hängenden Kette in beiden Variationen'}
knitr::include_graphics("figures/sheet-5/p3.png")
```